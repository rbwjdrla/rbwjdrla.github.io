---
title: "팩토리 메서드"
date: 2025-06-18 # 실제 작성 날짜
categories:
  - Software Engineering     
  - Design Patterns        
  - Creational Patterns          
tags:
  - DesignPattern
  - CreationalPattern
---

# 팩토리 메서드 패턴

## 1. 개요

팩토리 메서드 패턴은 **객체 생성**을 전담하는 디자인 패턴 중 하나이며, **생성(Creational) 패턴**에 속함. 이 패턴의 핵심 아이디어는 객체를 생성하는 인터페이스는 정의하되, 어떤 클래스의 인스턴스를 생성할지는 서브클래스에서 결정하도록 위임하는 것.

이를 통해 클라이언트 코드(객체를 사용하는 코드)가 특정 구체 클래스에 직접 의존하는 것을 방지하며, 새로운 클래스가 추가되더라도 기존 코드를 변경할 필요 없이 확장이 용이해짐. 즉, **"누가 만들지"를 서브클래스에 맡기는 방식.

## 2. 문제점 

일반적으로 객체를 생성할 때 `new` 키워드를 사용하여 특정 클래스의 인스턴스를 직접 생성함. 하지만 이 방식은 다음과 같은 문제를 야기할 수 있음:

* **강한 결합:** 클라이언트 코드가 구체적인 클래스에 직접적으로 의존하게 되어, 특정 클래스 구현이 변경되거나 새로운 클래스가 추가될 때마다 클라이언트 코드도 함께 수정해야 함.
* **유연성 부족:** 객체 생성 로직이 클라이언트 코드 내부에 흩어져 있어, 생성 방식이나 생성할 객체의 종류를 변경하기 어려움.
* **객체 생성의 복잡성:** 객체 생성이 복잡한 로직을 포함하거나 여러 단계를 거쳐야 할 경우, 클라이언트 코드가 지저분해질 수 있음.

## 3. 구성 요소 
팩토리 메서드 패턴은 주로 다음과 같은 구성 요소로 이루어짐.

1.  **Product:**
    * 팩토리 메서드가 생성할 객체의 인터페이스 또는 추상 클래스
    * 예: `Document`, `Pizza`

2.  **Concrete Product :**
    * Product 인터페이스를 구현하거나 Product 추상 클래스를 상속받는 구체적인 클래스
    * 예: `MyDocument`, `YourDocument`, `CheesePizza`, `PepperoniPizza`

3.  **Creator:**
    * 팩토리 메서드를 선언하는 추상 클래스 또는 인터페이스
    * 제품 객체를 반환하는 추상 팩토리 메서드를 포함
    * 객체를 생성하는 코드는 이 `Creator`의 서브클래스에 위임
    * 예: `DocumentCreator`, `PizzaStore`

4.  **Concrete Creator:**
    * Creator 추상 클래스를 상속받아 팩토리 메서드를 구현하는 클래스
    * 실제로 구체적인 제품 객체(Concrete Product)를 생성하고 반환
    * 예: `Application` (MyDocument 생성), `NYPizzaStore` (NY Style Pizza 생성), `ChicagoPizzaStore` (Chicago Style Pizza 생성)

## 4. 작동 원리

1.  **Creator**는 Product 타입의 객체를 반환하는 **팩토리 메서드(추상 메서드)**를 정의
2.  **Concrete Creator**는 이 팩토리 메서드를 오버라이드하여 **특정 Concrete Product**를 생성하고 반환
3.  클라이언트는 Creator 인터페이스를 통해 객체를 요청하며, 어떤 Concrete Creator를 사용할지에 따라 다른 Concrete Product를 얻게 됨
4.  클라이언트는 구체적인 제품 클래스에 대한 직접적인 지식 없이도 객체를 사용할 수 있음.

## 5. 장점

* **개방-폐쇄 원칙(Open/Closed Principle) 준수:** 새로운 제품 유형이 추가되더라도, 기존의 클라이언트 코드를 수정할 필요 없이 새로운 Concrete Product와 Concrete Creator만 추가하면 됨. (확장에는 열려 있고, 변경에는 닫혀 있음)
* **느슨한 결합(Loose Coupling):** 클라이언트 코드와 구체적인 제품 클래스 간의 직접적인 의존성을 제거함. 클라이언트는 Product 인터페이스에만 의존함.
* **단일 책임 원칙(Single Responsibility Principle) 준수:** 객체 생성 로직을 별도의 팩토리 클래스(Concrete Creator)로 분리하여 관리함.
* **유연성 및 확장성:** 다양한 제품을 쉽게 추가하고 관리할 수 있으며, 객체 생성 방식을 유연하게 변경할 수 있음.

## 6. 단점

* **클래스 수 증가:** 새로운 제품을 추가할 때마다 새로운 Concrete Product와 새로운 Concrete Creator를 생성해야 하므로, 클래스 수가 증가하고 시스템의 복잡성이 증가할 수 있음.
* **초기 학습 곡선:** 패턴의 구조와 역할 분담을 이해하는 데 시간이 필요할 수 있음.

## 7. 활용 예시

* 프레임워크나 라이브러리에서 사용자에게 특정 타입의 객체를 생성할 수 있는 방법을 제공하면서도, 구체적인 구현은 사용자에게 위임하고 싶을 때 사용함.
* 객체 생성이 복잡한 로직을 포함하거나 여러 단계가 필요할 때 사용함.
* 애플리케이션이 다양한 제품 군 중 하나를 동적으로 결정해야 할 때 (예: 운영체제에 따라 다른 UI 컴포넌트 생성) 사용함.
* 데이터베이스 연결, 로거 등과 같이 특정 환경에 따라 다른 구현이 필요한 객체를 생성할 때 사용함.
